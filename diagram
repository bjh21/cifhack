#! /usr/bin/perl

use warnings;
use strict;

use My::Schema;

use DateTime::Format::Natural;
use YAML;

my $sch = My::Schema->connect("dbi:SQLite:dbname=mca.sqlite");

my $conf = YAML::LoadFile($ARGV[0]);

my $dateparse = DateTime::Format::Natural->new(time_zone => 'Europe/London');
my ($from, $to);
if (ref($conf->{date}) eq 'ARRAY') {
    ($from, $to) = map $dateparse->parse_datetime($_), @{$conf->{date}};
} else {
    ($from, $to) = $dateparse->parse_datetime_duration($conf->{date});
}

# Axis-rendering code only works in whole hours.

$from->truncate(to => 'hour');
unless (defined $to) {
    $to = $from->clone->add(days => 1);
}
$to->truncate(to => 'hour');

# Convert bare TIPLOCs into ones with empty configuration.
for (@{$conf->{tiplocs}}) {
    $_ = { $_ => { } } unless ref;
}

# Separate TIPLOCS into names and configurations.
my @tiploc = map((keys(%$_))[0], @{$conf->{tiplocs}});
my %tiplocconf = map(%$_, @{$conf->{tiplocs}});

# Set default configuration.
for (keys %tiplocconf) {
    $tiplocconf{$_}{label} ||= $_;
}

my %tiplocmap;
for (my $i = 0; $i < @tiploc; $i++) {
    $tiplocmap{$tiploc[$i]} = $i;
}

my $line = 0;
my $lasttime;

sub tweaktime {
    my $offset = $from->delta_ms($_[0])->in_halfmins;
    $offset = -$offset if $_[0] < $from;
    $_[0] = $offset;
}

sub pass {
    tweaktime($_[0]);
    printf "%d %d %s\n", @_, $line ? 'cont' : 'start';
    $line = 1
}

sub arr {
    tweaktime($_[0]);
    printf "%d %d arr\n", @_;
}

sub dep {
    tweaktime($_[0]);
    printf "%d %d dep\n", @_;
}

sub done {
    if ($line) {
	printf "finish\n";
    }
    $line = 0;
    undef $lasttime;
}

print <<EOH;
%!PS-Adobe-3.1
%%Creator: diagram
%%DocumentSuppliedResources: procset bjh21-diagram 0 0
%%EndComments
%%BeginResource: procset bjh21-diagram 0 0
/bjh21-diagram
10 dict dup begin
/conv {
    36 mul exch
    tscale mul exch
} def

/start { conv moveto } def
/cont { conv lineto } def
/arr {  } def
/dep { gsave newpath conv 3 sub exch 3 sub exch moveto
    0 6 rlineto 6 0 rlineto 0 -6 rlineto closepath gsave
       1 setgray fill grestore 1 setlinewidth stroke grestore} def
/finish { stroke } def

/axes {
    3 dict begin
    /tiplocs exch def
    /hours exch def
    gsave 0.5 setlinewidth 0.5 setgray
    tiplocs length 1 sub
    0 1 hours length 1 sub { % for
	dup 120 mul 0 conv moveto dup 120 mul 2 index conv lineto
	hours exch get show
    } for
    stroke
    0.1 setlinewidth
    0 1 hours length 1 sub 12 mul {
	dup 10 mul 0 conv moveto dup 10 mul 2 index conv lineto pop
    } for
    stroke
    pop
    0.5 setlinewidth
    0 1 tiplocs length 1 sub
    { dup 0 exch conv moveto dup hours length 1 sub 120 mul exch conv lineto
	  tiplocs exch get show } for
    stroke grestore
    0 0 conv hours length 1 sub 120 mul tiplocs length 1 sub conv rectclip
    end
} def
end /ProcSet defineresource
%%EndResource
%%EndProlog
%%BeginSetup
<< /PageSize [ 841 595 ] >> setpagedevice
/bjh21-diagram /ProcSet findresource begin
%%EndSetup
%%Page 1 1
%%BeginPageSetup
1 setlinewidth
/Helvetica findfont 10 scalefont setfont
36 36 translate
%%EndPageSetup
userdict begin
EOH

sub DateTime::Duration::in_halfmins {
    my $self = shift;
    my ($m, $s) = $self->in_units('minutes', 'seconds');
    return $m * 2 + $s / 30;
}

my $stdwidth = 72*10;
print "/tscale ", $stdwidth / $from->delta_ms($to)->in_halfmins, " def\n";
print "[ ";
for (my $tick = $from->clone;
     $tick <= $to;
     $tick->add(hours => 1)) {
    printf "(%02d)", $tick->hour;
}
print "]\n";
print "[";
for (@tiploc) {
    printf "(%s)", $tiplocconf{$_}{label};
}
print "] axes\n";

my $rs;
if (exists $conf->{trains}) {
    my @train = @{$conf->{trains}};
    $rs = $sch->resultset('bs')->search({unique_id => \@train})
} else {
    $rs = $sch->resultset('bs')->search({ 'lis.tiploc' => \@tiploc },
					{ join => { crs => 'lis' },
					  group_by => ['me.lineno'],
					  having => \ "count(*) > 1"});
}

# Convert TSDB times into DateTimes.
# For the start of a service, the first argument is a DateTime representing
# the date on which the service starts.  It will be updated so as to be
# suitable for passing to resolve_cont.
# Trains seem to retain the absolute time zone in which they depart,
# so a train that leaves before 01:00 on the last Sunday in March continues
# to be timed in GMT throughout its journey rather than switching to BST
# at 01:00.

sub fix_offset {
    # DateTime::offset returns an offset in seconds.
    # DateTime::set_time_zone takes an offset in hours and minutes.
    # I sigh.
    my ($dt) = @_;
    my $off = $dt->offset;
    use integer;
    $off = sprintf("%+03d%02d", $off / 3600, ($off / 60) % 60);
    $dt->set_time_zone($off);
}

sub resolve_start {
    my $base = shift;
    my ($time) = @_;
    my ($hh, $mm, $h) = $time =~ /^(\d\d)(\d\d)(H?)/;
    $base->set(hour => $hh, minute => $mm, second => 30*!!$h);
    fix_offset($base);
    return $base->clone;
}

# For later stops, the first argument is a time updated by resolve_start
# or resolve_cont.
sub resolve_cont {
    my $base = shift;
    my $was = $base->clone->subtract(hours => 12);
    resolve_start($base, @_);
    $base->add(days => 1) if ($base <= $was);
    return $base->clone;
}

while (my $train = $rs->next) {
    for (my $day = $from->clone->truncate(to => 'day')->subtract(days => 1);
	 $day < $to;
	 $day->add(days => 1)) {
	if ($train->runs_on($day)) {
	    printf("%% %s (%s):\n", $train->unique_id, $day->ymd);
	    my $t = $day->clone;
	    eval {
		resolve_start($t, $train->lo->public_dep_time);
	    };
	    if ($@) {
		warn $train->unique_id . " on " . $day->ymd . ": $@\n";
		next;
	    }
	    for my $li ($train->lis) {
		if (exists $tiplocmap{$li->tiploc}) {
		    no warnings qw/uninitialized/;
		    printf("%% %-5s %-4s %-5s %-4s %-5s %s\n",
			   $li->sched_arr_time, $li->public_arr_time,
			   $li->sched_pass,
			   $li->public_dep_time, $li->sched_dep_time,
			   $li->tiploc);
		    arr(resolve_cont($t, $li->public_arr_time),
			$tiplocmap{$li->tiploc}) if $li->public_arr_time &&
			    $li->public_arr_time ne '0000';
		    for ($li->sched_arr_time, $li->sched_pass,
			 $li->sched_dep_time) {
			pass(resolve_cont($t, $_),
			     $tiplocmap{$li->tiploc}) if $_;
		    }
		    dep(resolve_cont($t, $li->public_dep_time), 
			$tiplocmap{$li->tiploc}) if $li->public_dep_time &&
			    $li->public_dep_time ne '0000';
		}
	    }
	    done;
	}
    }
} 

print "showpage end\n%%EOF\n";
