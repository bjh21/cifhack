#! /usr/bin/perl

use warnings;
use strict;

use My::Schema;

use DateTime::Format::Natural;
use YAML;

my $sch = My::Schema->connect("dbi:SQLite:dbname=mca.sqlite");

my $conf = YAML::LoadFile($ARGV[0]);

my $dateparse = DateTime::Format::Natural->new(time_zone => 'Europe/London');
my ($from, $to);
if (ref($conf->{date}) eq 'ARRAY') {
    ($from, $to) = map $dateparse->parse_datetime($_), @{$conf->{date}};
} else {
    ($from, $to) = $dateparse->parse_datetime_duration($conf->{date});
}

# Axis-rendering code only works in whole hours.

$from->truncate(to => 'hour');
unless (defined $to) {
    $to = $from->clone->add(days => 1);
}
$to->truncate(to => 'hour');

my @tiploc = @{$conf->{tiplocs}};

my %tiplocmap;
for (my $i = 0; $i < @tiploc; $i++) {
    $tiplocmap{$tiploc[$i]} = $i;
}

sub maptime {
    my ($time) = @_;
    my ($hh, $mm, $h) = $time =~ /^(\d\d)(\d\d)(H?)/;
    return $hh*120 + $mm*2 + !!$h;
}

my $line = 0;
my $lasttime;

sub tweaktime {
    $_[0] += 2880 if defined($lasttime) && $_[0] < $lasttime - 1440;
    $lasttime = $_[0];
}
sub pass {
    tweaktime($_[0]);
    printf "%d %d %s\n", @_, $line ? 'cont' : 'start';
    $line = 1
}

sub arr {
    tweaktime($_[0]);
    printf "%d %d arr\n", @_;
}

sub dep {
    tweaktime($_[0]);
    printf "%d %d dep\n", @_;
}

sub done {
    if ($line) {
	printf "finish\n";
    }
    $line = 0;
    undef $lasttime;
}

print <<EOH;
%!PS-Adobe-3.1
%%Creator: diagram
%%DocumentSuppliedResources: procset bjh21-diagram 0 0
%%EndComments
%%BeginResource: procset bjh21-diagram 0 0
/bjh21-diagram
10 dict dup begin
/conv {
    36 mul exch
    tscale mul exch
} def

/start { conv moveto } def
/cont { conv lineto } def
/arr { gsave newpath conv 3 sub moveto 0 6 rlineto
       0.1 setlinewidth stroke grestore } def
/dep { arr } def
/finish { stroke } def

/axes {
    3 dict begin
    /tiplocs exch def
    /hours exch def
    gsave 0.5 setlinewidth 0.5 setgray
    tiplocs length 1 sub
    0 1 hours length 1 sub { % for
	dup 120 mul 0 conv moveto dup 120 mul 2 index conv lineto
	hours exch get show
    } for
    stroke
    0.1 setlinewidth
    0 1 hours length 1 sub 12 mul {
	dup 10 mul 0 conv moveto dup 10 mul 2 index conv lineto pop
    } for
    stroke
    pop
    0.5 setlinewidth
    0 1 tiplocs length 1 sub
    { dup 0 exch conv moveto dup hours length 1 sub 120 mul exch conv lineto
	  tiplocs exch get show } for
    stroke grestore
    0 0 conv hours length 1 sub 120 mul tiplocs length 1 sub conv rectclip
    end
} def
end /ProcSet defineresource
%%EndResource
%%EndProlog
%%BeginSetup
<< /PageSize [ 841 595 ] >> setpagedevice
/bjh21-diagram /ProcSet findresource begin
%%EndSetup
%%Page 1 1
%%BeginPageSetup
1 setlinewidth
/Helvetica findfont 10 scalefont setfont
36 36 translate
%%EndPageSetup
userdict begin
EOH

sub DateTime::Duration::in_halfmins {
    my $self = shift;
    my ($m, $s) = $self->in_units('minutes', 'seconds');
    return $m * 2 + $s / 30;
}

my $stdwidth = 72*10;
print "/tscale ", $stdwidth / $from->delta_ms($to)->in_halfmins, " def\n";
print "[ ";
for (my $tick = $from->clone;
     $tick <= $to;
     $tick->add(hours => 1)) {
    printf "(%02d)", $tick->hour;
}
print "]\n";
print "[";
for (@tiploc) {
    printf "(%s)", $_;
}
print "] axes\n";

my $rs;
if (exists $conf->{trains}) {
    my @train = @{$conf->{trains}};
    $rs = $sch->resultset('bs')->search({unique_id => \@train})
} else {
    $rs = $sch->resultset('bs')->search({ 'lis.tiploc' => \@tiploc },
					{ join => { crs => 'lis' },
					  group_by => ['me.lineno'],
					  having => \ "count(*) > 1"});
}

while (my $train = $rs->next) {
    for (my $day = $from->clone->truncate(to => 'day')->subtract(days => 1);
	 $day < $to;
	 $day->add(days => 1)) {
	if ($train->runs_on($day)) {
	    my $offset = $from->delta_ms($day)->in_halfmins;
	    $offset = -$offset if $day < $from;
	    printf("%% %s (%s = %d):\n", $train->unique_id, $day->ymd, $offset);
	    for my $li (map $_->lis, $train->crs) {
		if (exists $tiplocmap{$li->tiploc}) {
		    no warnings qw/uninitialized/;
		    printf("%% %-5s %-4s %-5s %-4s %-5s %s\n",
			   $li->sched_arr_time, $li->public_arr_time,
			   $li->sched_pass,
			   $li->public_dep_time, $li->sched_dep_time,
			   $li->tiploc);
		    arr(maptime($li->public_arr_time) + $offset,
			$tiplocmap{$li->tiploc}) if $li->public_arr_time &&
			    $li->public_arr_time ne '0000';
		    for ($li->sched_arr_time, $li->sched_pass,
			 $li->sched_dep_time) {
			pass(maptime($_) + $offset,
			     $tiplocmap{$li->tiploc}) if $_;
		    }
		    dep(maptime($li->public_dep_time) + $offset, 
			$tiplocmap{$li->tiploc}) if $li->public_dep_time &&
			    $li->public_dep_time ne '0000';
		}
	    }
	    done;
	}
    }
} 

print "showpage end\n%%EOF\n";
